{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nimport { ethers } from 'ethers';\nimport { FLASH_LOAN_ADDRESS } from '../utils/constants';\nexport function useFlashLoan(flashLoanContract, signer, account) {\n  _s();\n  // Use timestamp-based nonce to avoid conflicts with previously used nonces\n  const [nonce, setNonce] = useState(() => Math.floor(Date.now() / 1000));\n  const [signature, setSignature] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [transactions, setTransactions] = useState([]);\n\n  // Use ref to track the nonce used in the last signature\n  const signedNonceRef = useRef(0);\n  const generateSignature = useCallback(async (token, amount) => {\n    if (!signer || !account) {\n      setError('Wallet not connected');\n      return null;\n    }\n    setIsLoading(true);\n    setError('');\n    try {\n      const currentNonce = nonce;\n      signedNonceRef.current = currentNonce;\n      const amountWei = ethers.parseEther(amount);\n\n      // Create message hash matching contract's format\n      const messageHash = ethers.solidityPackedKeccak256(['address', 'uint256', 'uint256', 'address'], [token, amountWei, currentNonce, FLASH_LOAN_ADDRESS]);\n\n      // Sign with personal_sign (adds Ethereum prefix)\n      const sig = await signer.signMessage(ethers.getBytes(messageHash));\n      setSignature(sig);\n      setNonce(currentNonce + 1);\n      return sig;\n    } catch (err) {\n      console.error('Error generating signature:', err);\n      setError(err.message || 'Failed to generate signature');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [signer, account, nonce]);\n  const executeFlashLoan = useCallback(async (token, amount, maxSlippageBps, sig) => {\n    if (!flashLoanContract || !signer) {\n      setError('Contract not initialized');\n      return false;\n    }\n    const signatureToUse = sig || signature;\n    if (!signatureToUse) {\n      setError('No signature available');\n      return false;\n    }\n    if (signedNonceRef.current === 0) {\n      setError('Please generate a signature first');\n      return false;\n    }\n    setIsLoading(true);\n    setError('');\n    const txRecord = {\n      hash: '',\n      type: 'flash_loan',\n      token,\n      amount,\n      status: 'pending',\n      timestamp: Date.now()\n    };\n    try {\n      const amountWei = ethers.parseEther(amount);\n\n      // Add transaction to history as pending\n      setTransactions(prev => [txRecord, ...prev]);\n\n      // Use the nonce that was used when signing\n      const tx = await flashLoanContract.requestFlashLoan(token, amountWei, maxSlippageBps, signedNonceRef.current, signatureToUse);\n      txRecord.hash = tx.hash;\n      setTransactions(prev => prev.map(t => t.timestamp === txRecord.timestamp ? {\n        ...t,\n        hash: tx.hash\n      } : t));\n      const receipt = await tx.wait();\n\n      // Parse events to get profit info\n      let profit = '0';\n      for (const log of receipt.logs) {\n        try {\n          const parsed = flashLoanContract.interface.parseLog({\n            topics: log.topics,\n            data: log.data\n          });\n          if ((parsed === null || parsed === void 0 ? void 0 : parsed.name) === 'FlashLoanExecuted') {\n            profit = ethers.formatEther(parsed.args.profit);\n          }\n        } catch {\n          // Skip logs that don't match our ABI\n        }\n      }\n\n      // Update transaction status\n      setTransactions(prev => prev.map(t => t.hash === tx.hash ? {\n        ...t,\n        status: 'success',\n        profit\n      } : t));\n\n      // Clear signature after successful execution\n      setSignature('');\n      return true;\n    } catch (err) {\n      var _err$data;\n      console.error('Error executing flash loan:', err);\n\n      // Update transaction status to failed\n      setTransactions(prev => prev.map(t => t.timestamp === txRecord.timestamp ? {\n        ...t,\n        status: 'failed'\n      } : t));\n\n      // Parse revert reason\n      let errorMessage = err.message || 'Transaction failed';\n      if (err.reason) {\n        errorMessage = err.reason;\n      } else if ((_err$data = err.data) !== null && _err$data !== void 0 && _err$data.message) {\n        errorMessage = err.data.message;\n      }\n      setError(errorMessage);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [flashLoanContract, signer, signature]);\n  const clearError = useCallback(() => {\n    setError('');\n  }, []);\n  return {\n    nonce,\n    signature,\n    isLoading,\n    error,\n    transactions,\n    generateSignature,\n    executeFlashLoan,\n    clearError\n  };\n}\n_s(useFlashLoan, \"C1qKOTYiJdDNPM/IuiQqhF7OUP8=\");","map":{"version":3,"names":["useState","useCallback","useRef","ethers","FLASH_LOAN_ADDRESS","useFlashLoan","flashLoanContract","signer","account","_s","nonce","setNonce","Math","floor","Date","now","signature","setSignature","isLoading","setIsLoading","error","setError","transactions","setTransactions","signedNonceRef","generateSignature","token","amount","currentNonce","current","amountWei","parseEther","messageHash","solidityPackedKeccak256","sig","signMessage","getBytes","err","console","message","executeFlashLoan","maxSlippageBps","signatureToUse","txRecord","hash","type","status","timestamp","prev","tx","requestFlashLoan","map","t","receipt","wait","profit","log","logs","parsed","interface","parseLog","topics","data","name","formatEther","args","_err$data","errorMessage","reason","clearError"],"sources":["C:/Users/Leo/OneDrive/Documentos/Faculdade INSA/Blockchain/project/flash-loan-project/frontend/src/hooks/useFlashLoan.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\r\nimport { ethers } from 'ethers';\r\nimport { Transaction } from '../types';\r\nimport { FLASH_LOAN_ADDRESS } from '../utils/constants';\r\n\r\nexport function useFlashLoan(\r\n  flashLoanContract: ethers.Contract | null,\r\n  signer: ethers.Signer | null,\r\n  account: string\r\n) {\r\n  // Use timestamp-based nonce to avoid conflicts with previously used nonces\r\n  const [nonce, setNonce] = useState(() => Math.floor(Date.now() / 1000));\r\n  const [signature, setSignature] = useState('');\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState('');\r\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n\r\n  // Use ref to track the nonce used in the last signature\r\n  const signedNonceRef = useRef(0);\r\n\r\n  const generateSignature = useCallback(\r\n    async (token: string, amount: string): Promise<string | null> => {\r\n      if (!signer || !account) {\r\n        setError('Wallet not connected');\r\n        return null;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      setError('');\r\n\r\n      try {\r\n        const currentNonce = nonce;\r\n        signedNonceRef.current = currentNonce;\r\n\r\n        const amountWei = ethers.parseEther(amount);\r\n\r\n        // Create message hash matching contract's format\r\n        const messageHash = ethers.solidityPackedKeccak256(\r\n          ['address', 'uint256', 'uint256', 'address'],\r\n          [token, amountWei, currentNonce, FLASH_LOAN_ADDRESS]\r\n        );\r\n\r\n        // Sign with personal_sign (adds Ethereum prefix)\r\n        const sig = await signer.signMessage(ethers.getBytes(messageHash));\r\n\r\n        setSignature(sig);\r\n        setNonce(currentNonce + 1);\r\n        return sig;\r\n      } catch (err: any) {\r\n        console.error('Error generating signature:', err);\r\n        setError(err.message || 'Failed to generate signature');\r\n        return null;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [signer, account, nonce]\r\n  );\r\n\r\n  const executeFlashLoan = useCallback(\r\n    async (\r\n      token: string,\r\n      amount: string,\r\n      maxSlippageBps: number,\r\n      sig?: string\r\n    ): Promise<boolean> => {\r\n      if (!flashLoanContract || !signer) {\r\n        setError('Contract not initialized');\r\n        return false;\r\n      }\r\n\r\n      const signatureToUse = sig || signature;\r\n      if (!signatureToUse) {\r\n        setError('No signature available');\r\n        return false;\r\n      }\r\n\r\n      if (signedNonceRef.current === 0) {\r\n        setError('Please generate a signature first');\r\n        return false;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      setError('');\r\n\r\n      const txRecord: Transaction = {\r\n        hash: '',\r\n        type: 'flash_loan',\r\n        token,\r\n        amount,\r\n        status: 'pending',\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      try {\r\n        const amountWei = ethers.parseEther(amount);\r\n\r\n        // Add transaction to history as pending\r\n        setTransactions((prev) => [txRecord, ...prev]);\r\n\r\n        // Use the nonce that was used when signing\r\n        const tx = await flashLoanContract.requestFlashLoan(\r\n          token,\r\n          amountWei,\r\n          maxSlippageBps,\r\n          signedNonceRef.current,\r\n          signatureToUse\r\n        );\r\n\r\n        txRecord.hash = tx.hash;\r\n        setTransactions((prev) =>\r\n          prev.map((t) => (t.timestamp === txRecord.timestamp ? { ...t, hash: tx.hash } : t))\r\n        );\r\n\r\n        const receipt = await tx.wait();\r\n\r\n        // Parse events to get profit info\r\n        let profit = '0';\r\n        for (const log of receipt.logs) {\r\n          try {\r\n            const parsed = flashLoanContract.interface.parseLog({\r\n              topics: log.topics as string[],\r\n              data: log.data,\r\n            });\r\n            if (parsed?.name === 'FlashLoanExecuted') {\r\n              profit = ethers.formatEther(parsed.args.profit);\r\n            }\r\n          } catch {\r\n            // Skip logs that don't match our ABI\r\n          }\r\n        }\r\n\r\n        // Update transaction status\r\n        setTransactions((prev) =>\r\n          prev.map((t) =>\r\n            t.hash === tx.hash ? { ...t, status: 'success', profit } : t\r\n          )\r\n        );\r\n\r\n        // Clear signature after successful execution\r\n        setSignature('');\r\n\r\n        return true;\r\n      } catch (err: any) {\r\n        console.error('Error executing flash loan:', err);\r\n\r\n        // Update transaction status to failed\r\n        setTransactions((prev) =>\r\n          prev.map((t) =>\r\n            t.timestamp === txRecord.timestamp ? { ...t, status: 'failed' } : t\r\n          )\r\n        );\r\n\r\n        // Parse revert reason\r\n        let errorMessage = err.message || 'Transaction failed';\r\n        if (err.reason) {\r\n          errorMessage = err.reason;\r\n        } else if (err.data?.message) {\r\n          errorMessage = err.data.message;\r\n        }\r\n\r\n        setError(errorMessage);\r\n        return false;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [flashLoanContract, signer, signature]\r\n  );\r\n\r\n  const clearError = useCallback(() => {\r\n    setError('');\r\n  }, []);\r\n\r\n  return {\r\n    nonce,\r\n    signature,\r\n    isLoading,\r\n    error,\r\n    transactions,\r\n    generateSignature,\r\n    executeFlashLoan,\r\n    clearError,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}